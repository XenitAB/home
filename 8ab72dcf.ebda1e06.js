(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{104:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return p}));var a=n(3),r=n(7),i=(n(0),n(142)),o=n(144),s={id:"networking",title:"Networking"},c={unversionedId:"xks/developer-guide/networking",id:"xks/developer-guide/networking",isDocsHomePage:!1,title:"Networking",description:"Network Policies",source:"@site/docs/xks/developer-guide/networking.md",slug:"/xks/developer-guide/networking",permalink:"/docs/xks/developer-guide/networking",editUrl:"https://github.com/xenitab/xenitab.github.io/edit/main/docs/xks/developer-guide/networking.md",version:"current",sidebar:"docs",previous:{title:"Flux",permalink:"/docs/xks/developer-guide/flux"},next:{title:"Secrets Managenent",permalink:"/docs/xks/developer-guide/secrets-management"}},l=[{value:"Network Policies",id:"network-policies",children:[{value:"Examples",id:"examples",children:[]},{value:"Debugging",id:"debugging",children:[]}]},{value:"Ingress",id:"ingress",children:[{value:"Private Ingress",id:"private-ingress",children:[]},{value:"Nginx Configuration",id:"nginx-configuration",children:[]},{value:"Debugging",id:"debugging-1",children:[]}]},{value:"Linkerd",id:"linkerd",children:[{value:"Get Started",id:"get-started",children:[]},{value:"FAQ",id:"faq",children:[]}]}],d={rightToc:l};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"network-policies"},"Network Policies"),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/services-networking/network-policies/"}),"Network Policies")," in Kubernetes adds the ability to allow and deny network traffic from specific pods and namespaces. Both\negress traffic from a Pod and ingress traffic to a Pod can be controlled. In a vanilla Kubernetes cluster all traffic between all namespaces is allowed by default. This is not the case in XKS. Out of\nthe box in XKS all tenant namespaces have a default deny rule added to them. This default deny rule will block any traffic going between namespaces. It will deny both ingress traffic from other\nnamespaces and egress traffic two other namespaces. All traffic within the namespace between Pods is allowed. The reasoning behind this setup is that Pods should not have more network access than they\nrequire to function, as it reduces the blast radius in the case of an exploit."),Object(i.b)("img",{alt:"Default Deny Network Policy",src:Object(o.a)("img/assets/xks/developer-guide/network-policy-default-deny.drawio.jpeg")}),Object(i.b)("p",null,"The default deny Network Policy contains an exception for traffic destined to the clusters DNS service. Without this exception DNS resolution would not work. The pod selector in the Network Policy is\nempty, this means that the Network Policy will apply for all Pods in the namespace."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny\n  namespace: tenant\nspec:\n  egress:\n    - ports:\n        - port: 53\n          protocol: UDP\n      to:\n        - namespaceSelector: {}\n          podSelector:\n            matchLabels:\n              k8s-app: kube-dns\n    - to:\n        - podSelector: {}\n  ingress:\n    - from:\n        - podSelector: {}\n  podSelector: {}\n  policyTypes:\n    - Ingress\n    - Egress\n")),Object(i.b)("p",null,"There may come a time when you have to create new Network Policies to allow specific Pods traffic as the default can be pretty restrictive. A common situations this is required is when a Pod needs to\ncommunicate to the public internet, or communicate between tenant namespaces. When creating new Network Policies make sure that you do not open up more than actually required. A good source of example\nNetwork Policies is the Github repository ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/ahmetb/kubernetes-network-policy-recipes"}),"kubernetes-network-policy-recipes"),". It contains a lot of good examples with diagrams and\ndescriptions. The examples on this page contains the most common use cases to make things simpler for you."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"A helpful tool when create new Network Policies is the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://editor.cilium.io/"}),"Cilium Network Policy Editor"),".")),Object(i.b)("h3",{id:"examples"},"Examples"),Object(i.b)("h4",{id:"allow-internet-egress"},"Allow Internet Egress"),Object(i.b)("p",null,"A common scenario is opening up traffic to the public internet. A current limitation with Network Policies today is that it is not possible to create egress rules based on DNS names. This means that\nthe simples solution is to allow traffic to all public IPs as trying to resolve the DNS to an IP would only work short term."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-internet-egress\nspec:\n  egress:\n    - to:\n        - ipBlock:\n            cidr: 0.0.0.0/0\n  podSelector:\n    matchLabels:\n      app: foo\n  policyTypes:\n    - Egress\n")),Object(i.b)("h4",{id:"allow-ingress-nginx"},"Allow Ingress Nginx"),Object(i.b)("p",null,"Traffic from the ingress controller has to be explicitly allowed as no traffic is allowed from outside the namespace by default. This can be considered a fail safe to protect against accidental\nIngress creation where an application is exposed to the internet when that was not the intent. It is enough to allow ingress from the ingress controller even if the traffic actually originates from\noutside the cluster."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-ingress-controller\nspec:\n  ingress:\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: ingress-nginx\n  podSelector:\n    matchLabels:\n      app: foo\n  policyTypes:\n  - Ingress\n")),Object(i.b)("h4",{id:"allow-cross-namespace"},"Allow Cross Namespace"),Object(i.b)("p",null,"When allowing network traffic across tenant namespaces considerations have to be made for the default deny Network Policy in both namespaces. An allow rule has to be created to allow the source\nnamespace, the side initating the connection, to send traffic to the other namespace. The destination namespace has to allow traffic from the source namespace. The first Network Policy should be used\nin the source namespace and the second should be used in the destination namespace."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-egress-to-destination\n  namespace: source\nspec:\n  egress:\n    - to:\n        - namespaceSelector:\n            matchLabels:\n              name: destination\n          podSelector:\n            matchLabels:\n              app: bar\n  podSelector:\n    matchLabels:\n      app: foo\n  policyTypes:\n    - Egress\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-ingress-from-source\n  namespace: destination\nspec:\n  ingress:\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: source\n          podSelector:\n            matchLabels:\n              app: foo\n  podSelector:\n    matchLabels:\n      app: bar\n  policyTypes:\n    - Ingress\n")),Object(i.b)("h3",{id:"debugging"},"Debugging"),Object(i.b)("p",null,"TBD"),Object(i.b)("h2",{id:"ingress"},"Ingress"),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/services-networking/ingress/"}),"Ingress")," in Kubernetes is used to allow network traffic from the outside the cluster to reach Pods inside the cluster. Ingress works\nas a layer ontop of Kubernetes Services by exposing the Service with a hostname. All Ingress traffic is Layer 7 routed meaning that traffic is routed based on the host header in the HTTP request. This\nalso means that Ingress only works with HTTP traffic. Doing it this way means that only a single load balancer is required reducing cost compared to running multiple load balancers, one per Ingress."),Object(i.b)("img",{alt:"Ingress Overview",src:Object(o.a)("img/assets/xks/developer-guide/ingress-overview.drawio.jpeg")}),Object(i.b)("p",null,"XKS comes with everything pre configured for Ingress to work. The cluster will either have a single ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.github.io/ingress-nginx/"}),"Nginx Ingress Controller")," which is exposed to the\npublic internet or two controllers where one is public and one is private. On top of that the cluster is configured with ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/kubernetes-sigs/external-dns"}),"External DNS")," which creates\nDNS records and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://cert-manager.io/docs/"}),"Cert Manager")," which deals with certificate creation and renewal. Together these three tools offer an automated solution where the complexity of DNS and\ncertificates are not handled by the application. The reccomendation is to always enabled TLS for all Ingress resources no matter how small the service is. Updating a certificate is\nquick and easy so there is no reason not to. Every XKS cluster comes with a preconfigured Cluster Issuer which will provision certificates from ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://letsencrypt.org/"}),"Lets Encrypt"),"."),Object(i.b)("p",null,"Start off with creating a Certificate resource for your Ingress. It is possible to have Cert Manager automatically create a Certificate when an Ingress resource is created. This however has the\ndownside that every Ingress resource will receive its own Certificate. Lets Encrypt has ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://letsencrypt.org/docs/rate-limits/"}),"rate limits")," for the same domain, if one were to create a\nCertificate per ingress that rate limit would be hit pretty quickly. That is why it is better to create a share Certificate per tenant namespace with multiple DNS names instead. Each DNS name will be\npresent in the Certificate so that it can be used for multiple Ingress resources. When the Certificate is provisioned it will be written to a Secret."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: shared\n  namespace: tenant\nspec:\n  issuerRef:\n    group: cert-manager.io\n    kind: ClusterIssuer\n    name: letsencrypt\n  dnsNames:\n    - app-one.example.com\n    - app-two.example.com\n  secretName: shared-cert\n")),Object(i.b)("p",null,"To complete the ingress configuration an Ingress resource has to be created. The Ingress resource defines the Service where the traffic should be routed to and the DNS name which should resolve to\nthat Service. An additional configuration is the tls configuration which configures the certificate to use. Cert Manager writes the certificate data to a Secret which is configured in the Certificate\nsecretName. That same Secret should be referenced in the tls configuration. A DNS record will be automatically created when the Ingress is applied to the cluster."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app-one\n  namespace: tenant\nspec:\n  rules:\n  - host: app-one.example.com\n    http:\n      paths:\n        - path: /\n          backend:\n            service:\n              name: app-one\n              port:\n                name: http\n  tls:\n    - hosts:\n        - app-one.example.com\n      secretName: shared-cert\n")),Object(i.b)("h3",{id:"private-ingress"},"Private Ingress"),Object(i.b)("p",null,"TBD"),Object(i.b)("h3",{id:"nginx-configuration"},"Nginx Configuration"),Object(i.b)("p",null,"It is useful to be aware of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#annotations"}),"annotation configuration")," in the nginx ingress controller.\nSometimes a specific ingress requires custom behavior that is not default in the ingress controller, this behavior can be customized with the help of annotations for a specific ingress resource.\nFor example changing the client body buffer size may be useful if the header size in a request is larger than the buffer."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: foo\n  namespace: bar\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    nginx.ingress.kubernetes.io/client-body-buffer-size: 1M\nspec:\n  rules:\n  - host: foo.dev.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: foo\n          servicePort: http\n  tls:\n    - hosts:\n      - foo.dev.example.com\n")),Object(i.b)("h3",{id:"debugging-1"},"Debugging"),Object(i.b)("p",null,"TBD"),Object(i.b)("h2",{id:"linkerd"},"Linkerd"),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://linkerd.io/"}),"Linkerd")," is an optional service mesh that can be added to XKS. The component is opt-in as it adds a certain amount of overhead,\nso unless it has bee done Linkerd will not be present in XKS. A service mesh extends the networking functionality in a Kubernetes cluster. It is\nuseful when features such as end to end encryption or GRPC load balancing is required. Linkerd will automatically handle TCP loadbalancing so when\nGRPC is used Linkerd will detect this and loadbalance between instances of GRPC servers."),Object(i.b)("p",null,"Refer to the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://linkerd.io/2.10/overview/"}),"oficial documentation")," for documentation that may be missing from this page."),Object(i.b)("p",null,"Linkerd works by injecting a sidecar into every Pod which uses Linkerd. All network requests have to be sent through the sidecar which will then be\nresponsible with forwarding it. The sidecar will hanlde things like traffic encryption before sending the packets outside of the node."),Object(i.b)("img",{alt:"Linkerd Overview",src:Object(o.a)("img/assets/xks/developer-guide/linkerd-overview.drawio.jpeg")}),Object(i.b)("h3",{id:"get-started"},"Get Started"),Object(i.b)("p",null,"To enable sidecar injection the Pod has to have the annotation ",Object(i.b)("inlineCode",{parentName:"p"},"linkerd.io/inject: enabled")," added to it. A common misstake when enabling Linkerd is\nthat the annotation is added to Deployment and not the Pod template, make sure that you do not do this misstake as the sidecar will not be injected if\nyou do."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: linkerd-test\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: linkerd-test\n  template:\n    metadata:\n      annotations:\n        linkerd.io/inject: enabled\n      labels:\n        app: linkerd-test\n    spec:\n      containers:\n      - name: linkerd-test\n        image: alpine:latest\n        ports:\n        - containerPort: 8080\n          name: http\n          protocol: TCP\n")),Object(i.b)("p",null,"Eventually a Pod should be created. A important detail is that there should be two containers in the Pod. One container should be the one defined in\nthe Deployment and the other one the Linkerd sidecar. This can be verified by getting the Pods containers."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'$ kubectl get pods <POD_NAME> -o jsonpath="{.spec.containers[*].name}"\nlinkerd-test linkerd-proxy\n')),Object(i.b)("p",null,"With the sidecar added all traffic going out of the container will automatically be proxied through the sidecar."),Object(i.b)("h3",{id:"faq"},"FAQ"),Object(i.b)("h4",{id:"is-all-network-traffic-encrypted"},"Is all network traffic encrypted?"),Object(i.b)("p",null,"No it depends on the traffic type and is something that should be verified rather than assumed. More information can be found in the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://linkerd.io/2.10/features/automatic-mtls/#"}),"Linkerd documentation"),"."),Object(i.b)("h4",{id:"what-overhead-can-i-expect"},"What overhead can I expect?"),Object(i.b)("p",null,"Each Pod will at minimum consume and additional 10 MB due to the extra sidecar and the number can grow as traffic increases."))}p.isMDXComponent=!0},142:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return b}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),d=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=d(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},h=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=d(n),h=a,b=p["".concat(o,".").concat(h)]||p[h]||u[h]||i;return n?r.a.createElement(b,s(s({ref:t},l),{},{components:n})):r.a.createElement(b,s({ref:t},l))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},143:function(e,t,n){"use strict";n.r(t);var a=n(0),r=n(20);t.default=function(){var e=Object(a.useContext)(r.a);if(null===e)throw new Error("Docusaurus context not provided");return e}},144:function(e,t,n){"use strict";n.d(t,"b",(function(){return i})),n.d(t,"a",(function(){return o}));var a=n(143),r=n(145);function i(){var e=Object(a.default)().siteConfig,t=(e=void 0===e?{}:e).baseUrl,n=void 0===t?"/":t,i=e.url;return{withBaseUrl:function(e,t){return function(e,t,n,a){var i=void 0===a?{}:a,o=i.forcePrependBaseUrl,s=void 0!==o&&o,c=i.absolute,l=void 0!==c&&c;if(!n)return n;if(n.startsWith("#"))return n;if(Object(r.b)(n))return n;if(s)return t+n;var d=n.startsWith(t)?n:t+n.replace(/^\//,"");return l?e+d:d}(i,n,e,t)}}}function o(e,t){return void 0===t&&(t={}),(0,i().withBaseUrl)(e,t)}},145:function(e,t,n){"use strict";function a(e){return!0===/^(\w*:|\/\/)/.test(e)}function r(e){return void 0!==e&&!a(e)}n.d(t,"b",(function(){return a})),n.d(t,"a",(function(){return r}))}}]);