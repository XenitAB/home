"use strict";(self.webpackChunkhome=self.webpackChunkhome||[]).push([[4914],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=o,m=u["".concat(l,".").concat(d)]||u[d]||h[d]||r;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5296:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return p},toc:function(){return h},default:function(){return d}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),i=["components"],s={title:"Kubernetes Ephemeral Container Security",description:"Ephemeral containers is a new concept in Kubernetes which allows attaching  containers to already running Pods. It also introduces new security concerns which have to be resolved before it can be enabled.\n",authors:"phillebaba",tags:["kubernetes","security","ephemeral containers"],keywords:["kubernetes","security","ephemeral containerss"]},l=void 0,c={permalink:"/blog/2022/04/12/ephemeral-container-security",source:"@site/blog/2022-04-12-ephemeral-container-security.md",title:"Kubernetes Ephemeral Container Security",description:"Ephemeral containers is a new concept in Kubernetes which allows attaching  containers to already running Pods. It also introduces new security concerns which have to be resolved before it can be enabled.\n",date:"2022-04-12T00:00:00.000Z",formattedDate:"April 12, 2022",tags:[{label:"kubernetes",permalink:"/blog/tags/kubernetes"},{label:"security",permalink:"/blog/tags/security"},{label:"ephemeral containers",permalink:"/blog/tags/ephemeral-containers"}],readingTime:8.815,truncated:!0,authors:[{name:"Philip Laine",title:"DevOps Engineer",url:"https://github.com/phillebaba/",email:"philip.laine@xenit.se",imageURL:"https://media-exp1.licdn.com/dms/image/C4E03AQG31KQ2xlivRA/profile-displayphoto-shrink_800_800/0/1598524888194?e=1655337600&v=beta&t=syoZr78rwDPb7Jj4d4B4opGNVCVZIa_3rmCkX-6oT2Q",key:"phillebaba"}],nextItem:{title:"Twelve-factor app anno 2022",permalink:"/blog/2022/02/23/12factor"}},p={authorsImageUrls:[void 0]},h=[{value:"Digging Deeper",id:"digging-deeper",children:[{value:"OPA Gatekeeper",id:"opa-gatekeeper",children:[],level:3},{value:"Kyverno",id:"kyverno",children:[],level:3},{value:"Pod Security Policies",id:"pod-security-policies",children:[],level:3},{value:"RBAC",id:"rbac",children:[],level:3}],level:2},{value:"Checking Policy Enforcement",id:"checking-policy-enforcement",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],u={toc:h};function d(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Attempting to debug a Pod and realizing that you can't install curl due to security settings has to be a meme at this point. Good security practices are always nice but it often comes at the cost of usability. To the point where some may even solve this problem by installing debug tools into their production images. Shudders."),(0,r.kt)("img",{src:"https://i.imgflip.com/6cczqi.jpg",title:"made at imgflip.com"}),(0,r.kt)("p",null,"Kubernetes has introduced a new concept called ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/"},"ephemeral containers"),' to deal with this problem. Ephemeral containers are temporary containers that can be attached after a Pod has been created. Rejoice! We can now attach a temporary container with all the tools which we desire. While the applications container may have "annoying security features" like a read only file system the ephemeral container can enjoy all the freedom which writing files entails. I love this feature so I need to upgrade my cluster immediately!'),(0,r.kt)("h2",{id:"digging-deeper"},"Digging Deeper"),(0,r.kt)("p",null,"Now that we have the new feature we can start a ephemeral container in any Pod we like."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl run ephemeral-demo --image=k8s.gcr.io/pause:3.1 --restart=Never\nkubectl debug -it ephemeral-demo --image=busybox:1.28\n")),(0,r.kt)("p",null,"We get a shell and life is now much simpler, but wait a minute. This post is not about how to use ephemeral containers, there are enough of those already, but rather the security implications of enabling ephemeral containers. Let's have a look at the YAML for the Pod that we created the ephemeral container in."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: ephemeral-demo\nspec:\n  ...\n  ephemeralContainers:\n  - name: debugger-r59b7\n    image: busybox:1.28\n    imagePullPolicy: IfNotPresent\n    stdin: true\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n    tty: true\n")),(0,r.kt)("p",null,"Interesting, there is a new field called ",(0,r.kt)("inlineCode",{parentName:"p"},"ephemeralContainers")," in the Pod definition. This new field contains a list of containers similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"initContainers")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"containers"),". It is not identical as there are certain options which are not available, refer to the ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#ephemeralcontainer-v1-core"},"API documentation")," for more information. It does however allow configuration of the container security context, which could in theory allow a bad actor to escalate the container's privileges. This should not affect those of us who use a policy enforcement tool right? The answer is yes and no depending on the tool and version that is being used. It also depends on if you are using policies from the project's library or policies developed in house."),(0,r.kt)("h3",{id:"opa-gatekeeper"},"OPA Gatekeeper"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/open-policy-agent/gatekeeper"},"OPA Gatekeeper")," does not require any code changes as all of its policies are written in ",(0,r.kt)("a",{parentName:"p",href:"https://www.openpolicyagent.org/docs/latest/policy-language/"},"rego"),". It's sub project ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/open-policy-agent/gatekeeper-library/"},"Gateekper Library")," does however have to be updated. The library contains an implementation of the common Pod Security Policies. This includes policies like not allowing containers in privileged mode. The issue with the all of the policies is that they currently only check containers specified in ",(0,r.kt)("inlineCode",{parentName:"p"},"initContainers")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"containers"),", analyze the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/open-policy-agent/gatekeeper-library/blob/275a1628694dcdf9daf5f6dda1373de6af78e7da/library/pod-security-policy/privileged-containers/template.yaml#L49-L55"},"following")," rego as an example."),(0,r.kt)("p",null,"The good news is that this is a pretty easy fix, the bad news is that it requires end users to update the policies pulled from the library."),(0,r.kt)("h3",{id:"kyverno"},"Kyverno"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/kyverno/kyverno"},"Kyverno")," seems to have resolved the issues faster. Compared to OPA Gatekeeper however it did require a small code change which means that version ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kyverno/kyverno/releases/tag/v1.5.3"},"1.5.3")," or later is needed to write policies for ephemeral containers. They have also ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kyverno/policies/pull/241"},"updated their policy library")," to include checking ephemeral containers. Kyverno has done a great job solving these issues quickly. It does still require end users to update however."),(0,r.kt)("h3",{id:"pod-security-policies"},"Pod Security Policies"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/security/pod-security-policy/"},"Pod Security Policies")," used to be the default policy tool for Kubernetes, and a lot of projects have rules based on Pod Security Policies (PSP). However if you are relying on PSP in a modern cluster you should really start looking for other options like OPA Gatekeeper or Kyverno. PSP has been deprecated since Kubernetes v1.21 and will be removed in v1.25."),(0,r.kt)("p",null,"If PSP is your only policy tool and you are planning to upgrade to v1.23, don't. As PSP is deprecated no new features have been added, and that includes policy enforcement on ephemeral containers. Which means that any security context in an ephemeral container is allowed no matter the PSP in the cluster.  The PSP below will have no affect when adding an ephemeral container to a Pod which is privileged."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: default\nspec:\n  privileged: false\n  seLinux:\n    rule: RunAsAny\n  supplementalGroups:\n    rule: RunAsAny\n  runAsUser:\n    rule: RunAsAny\n  fsGroup:\n    rule: RunAsAny\n  volumes:\n  - '*'\n")),(0,r.kt)("h3",{id:"rbac"},"RBAC"),(0,r.kt)("p",null,"Disallowing ephemeral containers with RBAC could be an option if the feature is not needed and it is not possible to disable the feature completely. The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/277-ephemeral-containers/README.md"},"KEP-277: Ephemeral Containers")," state the following about using RBAC to disable ephemeral containers."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Cluster administrators will be expected to choose from one of the following mechanisms for restricting usage of ephemeral containers:"),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"Use RBAC to control which users are allowed to access the /ephemeralcontainers subresource."),(0,r.kt)("li",{parentName:"ul"},"Write or use a third-party admission controller to allow or reject Pod updates that modify ephemeral containers based on the content of the update."),(0,r.kt)("li",{parentName:"ul"},"Disable the feature using the EphemeralContainers feature gate."))),(0,r.kt)("p",null,"RBAC is additive which means that it is not possible to remove permissions from a role. This type of mitigation obviously does not matter if all users a cluster admin, which they should not be, so we assume that new roles are created for the cluster consumers. In this case having a look at the existing roles can be enough to make sure that the subresource ",(0,r.kt)("inlineCode",{parentName:"p"},"/ephemeralcontainers")," is not included in the role."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: edit\nrules:\n- apiGroups:\n  - ""\n  resources:\n  - pods\n  - pods/attach\n  - pods/exec\n  - pods/portforward\n  - pods/proxy\n  verbs:\n  - create\n  - delete\n  - deletecollection\n  - patch\n  - update\n')),(0,r.kt)("h2",{id:"checking-policy-enforcement"},"Checking Policy Enforcement"),(0,r.kt)("p",null,"Let's say that you upgraded your cluster and informed all end users of the great new feature. How do you know that the correct policies are enforced in accordance to your security practices. You may have been aware of the API changes and taken the correct precautionary steps. Or you just updated Kyverno and it's policies out of pure happenstance. Either way it is good to trust but verify that it is not for example possible to create a privileged ephemeral container. Annoyingly the debug command does not expose any options to set any security context configuration, so we need another option. Ephemeral containers cannot be defined in a Pod when it is created and it can neither be added with an update. We need some other method to create these specific ephemeral containers."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Ephemeral containers are created using a special ephemeralcontainers handler in the API rather than by adding them directly to pod.spec, so it's not possible to add an ephemeral container using ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl edit"),".")),(0,r.kt)("p",null,"The simplest method to add an ephemeral container with a security context to a Pod is to use the Go client. A couple of lines of code can add a new ephemeral container running as privileged or use any other security context setting which is to your liking."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "context"\n    "fmt"\n    "os"\n\n    corev1 "k8s.io/api/core/v1"\n    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"\n    "k8s.io/client-go/kubernetes"\n    "k8s.io/client-go/tools/clientcmd"\n)\n\nfunc main() {\n    if len(os.Args) != 4 {\n        panic("expected three args")\n    }\n    podNamespace := os.Args[1]\n    podName := os.Args[2]\n    kubeconfigPath := os.Args[3]\n\n    // Create the client\n    client, err := getKubernetesClients(kubeconfigPath)\n    if err != nil {\n    panic(fmt.Errorf("could not create client: %w", err))\n    }\n    ctx := context.Background()\n\n    // Get the Pod\n    pod, err := client.CoreV1().Pods(podNamespace).Get(ctx, podName, metav1.GetOptions{})\n    if err != nil {\n    panic(fmt.Errorf("could not get pod: %w", err))\n    }\n\n    // Add a new ephemeral container\n    trueValue := true\n    ephemeralContainer := corev1.EphemeralContainer{\n        EphemeralContainerCommon: corev1.EphemeralContainerCommon{\n            Name:  "debug",\n            Image: "busybox",\n            TTY:   true,\n            SecurityContext: &corev1.SecurityContext{\n                Privileged:               &trueValue,\n                AllowPrivilegeEscalation: &trueValue,\n            },\n        },\n    }\n    pod.Spec.EphemeralContainers = append(pod.Spec.EphemeralContainers, ephemeralContainer)\n    pod, err = client.CoreV1().Pods(pod.Namespace).UpdateEphemeralContainers(ctx, pod.Name, pod, metav1.UpdateOptions{})\n    if err != nil {\n    panic(fmt.Errorf("could not add ephemeral container: %w", err))\n    }\n}\n\nfunc getKubernetesClients(path string) (kubernetes.Interface, error) {\n    cfg, err := clientcmd.BuildConfigFromFlags("", path)\n    if err != nil {\n        return nil, err\n    }\n    client, err := kubernetes.NewForConfig(cfg)\n    if err != nil {\n        return nil, err\n    }\n    return client, nil\n}\n')),(0,r.kt)("p",null,"Run the program and pass the namespace, pod name, and path to a kube config file. We assume that the ephemeral-demo Pod is still running. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"go run main.go default ephemeral-demo $KUBECONFIG\n")),(0,r.kt)("p",null,"If it completes with no error a privileged ephemeral container should have been added to the Pod. Exec into it and list the host's devices to prove that it is a privileged container."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl exec -it ephemeral-demo -c debug -- sh\nls /dev\n")),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"If there is one takeaway from this post, it is that any policy tool that has not been updated in the last couple of months will not enforce rules on ephemeral containers. This also includes all policies written in house! It is not enough to update the community policies."),(0,r.kt)("p",null,"Some may argue that this type of oversight is not really an issue. Ephemeral containers can't mount ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/storage/volumes/#hostpath"},"host paths"),", or access the ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/security/pod-security-policy/#host-namespaces"},"hosts namespaces"),". All it can do is set the common container security context. That is a fair comment, because it's true. Being able to create a privileged container is however still not ideal, and there are ",(0,r.kt)("a",{parentName:"p",href:"https://bishopfox.com/blog/kubernetes-pod-privilege-escalation#Pod3"},"methods to escalate privileges")," when this is possible. Either way it is important to be aware of how policies are enforced and the security contexts which are allowed."),(0,r.kt)("p",null,"I am still not sure how much of an issue this will be short term. Cloud providers are currently in the process of rolling out Kubernetes v1.23 in their SaaS offerings. In these solutions it is still a possibility that they chose to disable ephemeral containers. Those rolling their own clusters may have already upgraded to v1.23 and not be aware of the new feature. That is the biggest issue really, that the platform administrator has to be aware of the existence of ephemeral containers. The fact that kubectl does not expose the option to set a security context will make even less people aware that it is still possible to set one with other means. Investing in a security audit 6 months ago will only be valuable as long as the same Kubernetes version is used. Kubernetes is by design ",(0,r.kt)("strong",{parentName:"p"},"not")," secure by default, so each new feature introduced has to be analyzed. The fact that upgrading from Kubernetes v1.22 to v.23 could make your cluster less secure is part of the difficulties of working with Kubernetes, requiring platform administrators to always stay on top of things. The reality is that these types of things are easy to miss, so hopefully this post has helped someone make their cluster a bit more secure."))}d.isMDXComponent=!0}}]);