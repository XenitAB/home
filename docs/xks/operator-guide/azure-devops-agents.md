---
id: azure-devops-agents
title: Azure DevOps agents
---

import useBaseUrl from '@docusaurus/useBaseUrl';

Instead of using the default agent in azure we use a VMSS (Virtual machine scale set)

To configure azure agent we need to run a few steps in a specific order.

- In Governance add hub & azpagent
- Configure & run packer, which generates a vm image
- hub with the correct packer file defined
- core & hub with "peering_config" defined

## Governance

First you need to update your governance template. It should include a definition for hub & azpagent.

It should look something like this:

```.tfvars
  {
    common_name                = "hub",
    delegate_aks               = false,
    delegate_key_vault         = true,
    delegate_service_endpoint  = false,
    delegate_service_principal = false,
    lock_resource_group        = false,
    tags = {
      "description" = "Used for main dns"
    }
  },
  {
    common_name                = "azpagent",
    delegate_aks               = false,
    delegate_key_vault         = true,
    delegate_service_endpoint  = false,
    delegate_service_principal = true,
    lock_resource_group        = false,
    tags = {
      "description" = "Azure Pipelines Agent"
    }
  },

```

## Setup packer repo

To create a vm image and we utilize [packer](https://www.packer.io/), here you can find a [template](https://github.com/XenitAB/azure-devops-templates/tree/main/packer-docker) for our packer.

- Create a new git repo located in azure, for example call it packer.
- Create a new pipeline pointing it to .ci/azure-pipelines-agent.yaml

Ether start a build in Azure DevOps or on your local client using the Make command.

The job will take about **40** minutes.

### Terraform configure packer image

You should now be able to see a vm image in your resource group.

Grab the name of the agent and add to your hub terraform config.

```shell
# Assuming that you don't have any other image this RG.
az image list -o json --query '[0].name'
```

In my case it's called azp-agent-2021-04-09T08-18-30Z.

## Configure Azure devops

To be able to communicate with the VMSS we need to configure a Service connection.

You will find service connection under a random project within azure devops.

To setup the service connection you need to get a secret generated by terraform.

```shell
# Assuming that you are connected to the correct subscription
az keyvault secret show --vault-name <vault-name> --name <secret-name> -o tsv --query value
# Example:
az keyvault secret show --vault-name kv-prod-we-core-1337 --name sp-rg-xks-prod-azpagent-contributor -o tsv --query value
```

### configure Service connections

To create a new Service connection from Azure Devops:

Project settings -> Service connections -> New service connection -> Azure Resource Manager -> Service principal (manual)

{"clientId":"12345","clientSecret":"SoMuchSecret","subscriptionId":"sub-id","tenantId":"tenant-id"}

- Subscription Id = subscriptionId
- Service Principal Id = clientId
- Service principal key = clientSecret
- Tenant ID = tenantId
- Service connection name = random-name

### Setup Agent Pool

In Azure DevOps under project settings.

Agent pools -> Add Pool -> Pick VMSS from dropdown

<img alt="Agent image" src={useBaseUrl("img/assets/xks/operator-guide/agent_pool.png")} />

### Azure Devops Billing

Configure billing.

This will increase your azure cost. Read up on how much on your own.

Organization Settings -> Billing

Under "Self-Hosted CI/CD" set "Paid parallel jobs" = 3

## Peering config

We need to setup peering_config between the hub and the core resource group.

This to be able to talk from Azure DevOps agent VMSS pool to the core network.

Bellow you can find a example on how you can do it:

hub/variables/prod.tfvars

```.tfvars
peering_config = [
  {
    name                         = "core-dev"
    remote_virtual_network_id    = "/subscriptions/your-sub-id/resourceGroups/rg-dev-we-core/providers/Microsoft.Network/virtualNetworks/vnet-dev-we-core"
    allow_forwarded_traffic      = true
    use_remote_gateways          = false
    allow_virtual_network_access = true
  },
]
```

core/variables/dev.tfvars

```.tfvars
peering_config = [
  {
    name                         = "hub"
    remote_virtual_network_id    = "/subscriptions/your-sub-id/resourceGroups/rg-prod-we-hub/providers/Microsoft.Network/virtualNetworks/vnet-prod-we-hub"
    allow_forwarded_traffic      = true
    use_remote_gateways          = false
    allow_virtual_network_access = true
  },
]
```

After your terraform code is applied you should be able to see that your two vnets is connected:

```shell
az network vnet list -o json --query '[0].virtualNetworkPeerings'
```
